# SimWorks Documentation

## Overview
SimWorks is a Django-based training platform that delivers chat-driven clinical simulations with AI-assisted interactions and persistent scenario records for review and assessment.【F:PROJECT_OVERVIEW.md†L1-L5】 The project is organized as a multi-app Django site complemented by shared Python packages for AI orchestration and integration tooling.【F:PROJECT_OVERVIEW.md†L8-L36】【F:pyproject.toml†L1-L38】

SimWorks ships several first-party Django apps:

- `accounts` – custom user model, invitations, and role/resource authorizations.【F:PROJECT_OVERVIEW.md†L10-L18】【F:SimWorks/accounts/models.py†L15-L170】
- `core` – shared middleware, views, and utilities that enforce platform-wide concerns such as health checks and GraphQL access controls.【F:PROJECT_OVERVIEW.md†L12-L13】【F:SimWorks/core/middleware.py†L4-L14】【F:SimWorks/core/views/views.py†L13-L48】
- `simcore` – domain models for simulations, metadata, patient context, clinical results, media, and AI responses.【F:PROJECT_OVERVIEW.md†L14-L40】【F:SimWorks/simcore/models.py†L40-L721】
- `chatlab` – chat-specific session models and message handling layered on simulations.【F:PROJECT_OVERVIEW.md†L16-L33】【F:SimWorks/chatlab/models.py†L20-L157】

TrainerLab is present in the codebase but not yet covered by this documentation, per the current scope agreement.

## Runtime architecture
The Django project enables HTTP and WebSocket workloads using Channels, Daphne, and Redis, with Celery providing asynchronous execution and scheduling.【F:pyproject.toml†L6-L38】【F:SimWorks/config/settings.py†L45-L218】 Environment configuration is driven by `config/settings.py`, which wires a custom user model, HTMX support, health-check middleware, templating, database selection (SQLite for development or PostgreSQL), Redis-backed channel layers, and Celery queues.【F:SimWorks/config/settings.py†L43-L218】 AI providers and clients are centrally configured through the `SIMCORE_AI` settings block, allowing per-provider API credentials, defaults, retry policies, and execution backend controls (Celery or immediate).【F:SimWorks/config/settings.py†L130-L193】 Static and media assets use Django’s standard directories, and Logfire instrumentation is enabled for HTTPX, Django, and OpenAI traffic observability.【F:SimWorks/config/settings.py†L251-L283】

The repository also hosts two workspace Python packages, `simcore-ai` and `simcore-ai-django`, which supply framework-agnostic AI abstractions and Django-specific orchestration helpers respectively.【F:pyproject.toml†L36-L45】【F:packages/simcore_ai/src/simcore_ai/__init__.py†L1-L36】 These packages integrate tightly with the Django apps to handle service execution, tracing, auditing, and codec processing for AI-driven simulations.【F:packages/simcore_ai_django/src/simcore_ai_django/tasks.py†L1-L25】【F:packages/simcore_ai_django/src/simcore_ai_django/runner.py†L1-L265】

## Accounts app
`accounts.CustomUser` extends Django’s `AbstractUser` with a required `UserRole` relationship and scenario-log helpers. The helpers expose both synchronous and asynchronous variants that filter simulations by recent activity windows and return summarized metadata (ID, timestamps, diagnosis, chief complaint).【F:SimWorks/accounts/models.py†L15-L63】 Roles aggregate resources through `RoleResource` entries, with convenience methods to emit the resource list in either list or string form for downstream authorization checks.【F:SimWorks/accounts/models.py†L66-L103】 Invitation flows persist invitation metadata, set secure tokens on save, enforce claim bookkeeping, and expose absolute URLs for token-based registration.【F:SimWorks/accounts/models.py†L106-L170】 Together these models supply the user, role, and onboarding primitives required to control access to simulations and auxiliary tooling.

## SimCore domain
`simcore.BaseSession` offers a shared one-to-one session abstraction for lab-specific extensions, ensuring timestamp tracking and optional note-taking for any simulation-attached session model.【F:SimWorks/simcore/models.py†L40-L75】 The central `Simulation` model captures lifecycle timestamps, time limits, associated user, AI prompt metadata, diagnosis details, and generated patient identities while providing helpers to inspect status (in progress, completed, timed-out), compute durations, retrieve previous AI responses, and generate patient initials.【F:SimWorks/simcore/models.py†L78-L244】 Ending a simulation stamps the end time and triggers asynchronous feedback generation, while the async-friendly `build`/`abuild` constructors normalize user inputs, create the simulation, and kick off initial AI response workflows.【F:SimWorks/simcore/models.py†L245-L337】

Simulation metadata subclasses provide structured storage for labs, radiology results, demographics, histories, and feedback, enforcing per-key uniqueness and updating a checksum whenever metadata changes.【F:SimWorks/simcore/models.py†L401-L578】 Patient history entries expose `to_dict` summaries and track whether conditions are resolved, while lab and radiology results capture reference ranges, flags, and serialization helpers for API presentation.【F:SimWorks/simcore/models.py†L461-L559】 `SimulationImage` instances manage media files, derived thumbnails, MIME validation, and provider identifiers, and `AIResponse` objects persist normalized AI outputs alongside token accounting with indexes optimized for chronological lookups and provider correlation.【F:SimWorks/simcore/models.py†L580-L721】 The history registry aggregates per-app history providers to emit unified simulation timelines or formatted exports for downstream consumers.【F:SimWorks/simcore/history_registry.py†L11-L40】

## ChatLab
`chatlab.ChatSession` is a thin extension of `BaseSession`, inheriting all simulation coupling behavior so chat-specific metadata can be layered in future iterations.【F:SimWorks/chatlab/models.py†L20-L26】【F:SimWorks/simcore/models.py†L40-L75】 The `Message` model stores message ordering, sender roles, media attachments, AI linkage, provider response IDs, and status flags such as read/deleted. It auto-increments an `order` field per simulation, supports multiple message types (text, image, video, audio, file, system), and exposes helper methods for AI payload formatting and media detection.【F:SimWorks/chatlab/models.py†L29-L145】 `MessageMediaLink` supplies the join table between chat messages and stored simulation images, enforcing uniqueness to prevent duplicate attachments.【F:SimWorks/chatlab/models.py†L58-L157】 These constructs enable rich chat transcripts that blend human and AI utterances with multimedia context.

## Core platform services
The `core` app provides a session-counting index view, a `PrivateGraphQLView` that restricts access to authenticated staff or users with the `core.read_api` permission, and a robots.txt view for crawler directives.【F:SimWorks/core/views/views.py†L13-L48】 `HealthCheckMiddleware` injects a lightweight `/health` endpoint returning JSON status, simplifying deployment readiness checks.【F:SimWorks/core/middleware.py†L4-L14】 The settings module also configures Strawberry GraphQL defaults, CSRF behavior, and other cross-cutting concerns referenced by these views.【F:SimWorks/config/settings.py†L33-L102】【F:SimWorks/config/settings.py†L286-L290】

## AI execution pipeline
Background AI workflows are orchestrated through the `simcore_ai_django` package. Celery exposes the `run_service_task` shared task, which resolves a service path, instantiates it with provided kwargs, and delegates to the synchronous service runner while preserving distributed tracing metadata.【F:packages/simcore_ai_django/src/simcore_ai_django/tasks.py†L1-L25】 The `run_service`/`arun_service` entrypoints wrap service request construction, audit logging, event dispatching, provider invocation, codec execution, and final response signaling with rich telemetry spans and failure handling hooks.【F:packages/simcore_ai_django/src/simcore_ai_django/runner.py†L61-L360】 Codec execution is optional but, when present, receives the promoted response plus contextual information (request and response audit IDs, namespace, service, settings) for validation or persistence before the pipeline emits a `response_ready` signal.【F:packages/simcore_ai_django/src/simcore_ai_django/runner.py†L214-L265】 This stack forms the bridge between the framework-agnostic AI abstractions and the persisted Django simulation data, ensuring traceable, repeatable AI interactions.

## Observability and instrumentation
`SIMCORE_AI` settings enable retry tuning, timeout management, health checks, and per-client enablement flags, while Logfire instrumentation applies to HTTPX calls, Django views, and OpenAI SDK interactions for consistent tracing across sync and async flows.【F:SimWorks/config/settings.py†L130-L193】【F:SimWorks/config/settings.py†L274-L283】 AI request/response audits, emission hooks, and codec execution are wrapped in tracing spans in the runner, providing end-to-end visibility when paired with Celery’s retry/backoff strategy.【F:packages/simcore_ai_django/src/simcore_ai_django/tasks.py†L10-L25】【F:packages/simcore_ai_django/src/simcore_ai_django/runner.py†L91-L265】 Health monitoring is augmented by the built-in `/health` middleware response, facilitating integration with load balancers or uptime checks.【F:SimWorks/core/middleware.py†L4-L14】 Together these mechanisms surface operational telemetry across the simulation lifecycle.

## Testing and tooling
Pytest is configured as the default test runner via `pyproject.toml`, targeting the `config.settings` module and loading tests from the `tests/` hierarchy with quiet reporting enabled.【F:pyproject.toml†L47-L50】 The repository relies on `uv` for workspace-aware dependency management and script execution, including the bundled `simcore-ai` packages that participate in the Django project as editable workspace members.【F:pyproject.toml†L6-L45】 Developers should continue using the `uv run` workflow to install dependencies, run migrations, and execute tests, as detailed in the quick-start guide.

## Development volume recovery
If your existing development Docker volumes have root-owned files that block `collectstatic` in the new non-root flow, run this one-time rescue command to fix ownership:

```bash
docker compose -f docker/compose.dev.yaml run --rm --user root server sh -lc \
  'chown -R 10001:10001 /app/static /app/media && chmod -R u+rwX /app/static /app/media'
```
